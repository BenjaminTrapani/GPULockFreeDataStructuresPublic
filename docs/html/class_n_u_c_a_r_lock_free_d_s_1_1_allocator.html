<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: NUCARLockFreeDS::Allocator&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_n_u_c_a_r_lock_free_d_s.html">NUCARLockFreeDS</a></li><li class="navelem"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">Allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">NUCARLockFreeDS::Allocator&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_allocator_8hpp_source.html">Allocator.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_per_thread_state.html">PerThreadState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_p_list.html">PList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3931e84d06ddd3b436103475197eb12a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a3931e84d06ddd3b436103475197eb12a">Pointer_t</a> = unsigned long long int</td></tr>
<tr class="separator:a3931e84d06ddd3b436103475197eb12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7636b4884545094b9532cc295604b17"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#aa7636b4884545094b9532cc295604b17">This_t</a> = <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;</td></tr>
<tr class="separator:aa7636b4884545094b9532cc295604b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508d82b795e6c1977bebb67b5e5b686"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> = ILink_t</td></tr>
<tr class="separator:a5508d82b795e6c1977bebb67b5e5b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2776cca35e8343bf5007bd8b6f3a3f8f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a> = IIndex_t</td></tr>
<tr class="separator:a2776cca35e8343bf5007bd8b6f3a3f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44b7846713e20e26a7eede2492fda47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#ac44b7846713e20e26a7eede2492fda47">Node_t</a> = <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a></td></tr>
<tr class="separator:ac44b7846713e20e26a7eede2492fda47"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc2d0f788ae4d12cdfb3b2d3e8075c77"><td class="memItemLeft" align="right" valign="top">__device__&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#adc2d0f788ae4d12cdfb3b2d3e8075c77">Allocator</a> ()</td></tr>
<tr class="separator:adc2d0f788ae4d12cdfb3b2d3e8075c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c5eef54aaebcad88edb0e87d5b7557"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a02c5eef54aaebcad88edb0e87d5b7557">DeRefLink</a> (<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> *link)</td></tr>
<tr class="separator:a02c5eef54aaebcad88edb0e87d5b7557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4e8ba73a5018483ca63c09f94daca3"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a7c4e8ba73a5018483ca63c09f94daca3">ReleaseRef</a> (<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> link)</td></tr>
<tr class="separator:a7c4e8ba73a5018483ca63c09f94daca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eeb962b3169fa2bdffe85e7d682dfa9"><td class="memItemLeft" align="right" valign="top">__device__ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a9eeb962b3169fa2bdffe85e7d682dfa9">CompareAndSwapRef</a> (<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> *link, const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> old, const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> node)</td></tr>
<tr class="separator:a9eeb962b3169fa2bdffe85e7d682dfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cd8b51995e5cebbc937a3a01aa1eff"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a08cd8b51995e5cebbc937a3a01aa1eff">StoreRef</a> (<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> *link, <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> node)</td></tr>
<tr class="separator:a08cd8b51995e5cebbc937a3a01aa1eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4749c1ddff91fcdff56e750545a6790a"><td class="memItemLeft" align="right" valign="top">__device__ <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a4749c1ddff91fcdff56e750545a6790a">NewNode</a> ()</td></tr>
<tr class="separator:a4749c1ddff91fcdff56e750545a6790a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2abafd921e216ec08249198da2d3d2"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a3f2abafd921e216ec08249198da2d3d2">DeleteNode</a> (<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> link)</td></tr>
<tr class="separator:a3f2abafd921e216ec08249198da2d3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a44f1e3d3b32739a116a7acccae7b29db"><td class="memItemLeft" align="right" valign="top">static __device__ bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a44f1e3d3b32739a116a7acccae7b29db">CompareAndSwapLinks</a> (<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> *link, const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> &amp;old, const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> &amp;node)</td></tr>
<tr class="separator:a44f1e3d3b32739a116a7acccae7b29db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1b9fa15fea39ba361ca1cdc5bfaeb9"><td class="memTemplParams" colspan="2">template&lt;typename TypeToRead &gt; </td></tr>
<tr class="memitem:a1d1b9fa15fea39ba361ca1cdc5bfaeb9"><td class="memTemplItemLeft" align="right" valign="top">static __device__ TypeToRead&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a1d1b9fa15fea39ba361ca1cdc5bfaeb9">atomicRead</a> (TypeToRead *pLink)</td></tr>
<tr class="separator:a1d1b9fa15fea39ba361ca1cdc5bfaeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb86daaaec98eadd094bc3f6520bb1d8"><td class="memTemplParams" colspan="2">template&lt;typename TypeToWrite &gt; </td></tr>
<tr class="memitem:abb86daaaec98eadd094bc3f6520bb1d8"><td class="memTemplItemLeft" align="right" valign="top">static __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#abb86daaaec98eadd094bc3f6520bb1d8">atomicWrite</a> (TypeToWrite *pLink, const TypeToWrite &amp;val)</td></tr>
<tr class="separator:abb86daaaec98eadd094bc3f6520bb1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3bf029c737539d9bfa9c9296ac17d83b"><td class="memTemplParams" colspan="2">template&lt;Index_t height, Index_t width&gt; </td></tr>
<tr class="memitem:a3bf029c737539d9bfa9c9296ac17d83b"><td class="memTemplItemLeft" align="right" valign="top">__device__ <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a3bf029c737539d9bfa9c9296ac17d83b">findIndexWhereEqual</a> (<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *input[height][width], const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a> callingThread, const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *expected)</td></tr>
<tr class="separator:a3bf029c737539d9bfa9c9296ac17d83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd90fb5b60a5e8099775c1725a0613d"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a8bd90fb5b60a5e8099775c1725a0613d">updateRefCounts</a> (<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *old, <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *node)</td></tr>
<tr class="separator:a8bd90fb5b60a5e8099775c1725a0613d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfba24913e993f6572d4a5b0f6c701c"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#afdfba24913e993f6572d4a5b0f6c701c">CleanUpLocal</a> (const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a> callingThread)</td></tr>
<tr class="separator:afdfba24913e993f6572d4a5b0f6c701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0498950ecff0d5354daab89e8f12d6d5"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a0498950ecff0d5354daab89e8f12d6d5">CleanUpAll</a> ()</td></tr>
<tr class="separator:a0498950ecff0d5354daab89e8f12d6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5813e074d787aa0fc50f1b02061a973"><td class="memItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#ab5813e074d787aa0fc50f1b02061a973">Scan</a> (const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a> callingThread)</td></tr>
<tr class="separator:ab5813e074d787aa0fc50f1b02061a973"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a14e7ae467e3fefce5ce92aa3017b1568"><td class="memItemLeft" align="right" valign="top">TerminateNode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a14e7ae467e3fefce5ce92aa3017b1568">TerminateNode</a></td></tr>
<tr class="separator:a14e7ae467e3fefce5ce92aa3017b1568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae185b38ec0a4ca4ccbe4ec0060ca834b"><td class="memItemLeft" align="right" valign="top">CleanUpNode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#ae185b38ec0a4ca4ccbe4ec0060ca834b">CleanUpNode</a></td></tr>
<tr class="separator:ae185b38ec0a4ca4ccbe4ec0060ca834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcefaf024a5ea626d6e045aab70057b9"><td class="memItemLeft" align="right" valign="top">GetThisThreadID_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#adcefaf024a5ea626d6e045aab70057b9">GetThisThreadID</a></td></tr>
<tr class="separator:adcefaf024a5ea626d6e045aab70057b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af296445f1e849188577b21cdc924b09e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#af296445f1e849188577b21cdc924b09e">HP</a> [numThreads][indicesPerThread]</td></tr>
<tr class="separator:af296445f1e849188577b21cdc924b09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040473eedb2591853976bd963e8522e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a040473eedb2591853976bd963e8522e6">DLNodes</a> [numThreads][<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a1d220e1cc963fc9fb37e46a416504715">threshold1</a>]</td></tr>
<tr class="separator:a040473eedb2591853976bd963e8522e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50f17cb2e163dbd88a3fcb492b1dde2"><td class="memItemLeft" align="right" valign="top">volatile int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#aa50f17cb2e163dbd88a3fcb492b1dde2">DLClaims</a> [numThreads][<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a1d220e1cc963fc9fb37e46a416504715">threshold1</a>]</td></tr>
<tr class="separator:aa50f17cb2e163dbd88a3fcb492b1dde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93543d254eaef573bd4fb471c79ae29"><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#af93543d254eaef573bd4fb471c79ae29">DLDone</a> [numThreads][<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a1d220e1cc963fc9fb37e46a416504715">threshold1</a>]</td></tr>
<tr class="separator:af93543d254eaef573bd4fb471c79ae29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04805cb0313b2b7cfd5c76830fdb0c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_per_thread_state.html">PerThreadState</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#aa04805cb0313b2b7cfd5c76830fdb0c8">perThreadState</a> [numThreads]</td></tr>
<tr class="separator:aa04805cb0313b2b7cfd5c76830fdb0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:a1d220e1cc963fc9fb37e46a416504715"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a1d220e1cc963fc9fb37e46a416504715">threshold1</a> = numThreads * (indicesPerThread + maxLinks + maxLinksToDeletedNode + 1)</td></tr>
<tr class="separator:a1d220e1cc963fc9fb37e46a416504715"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2776cca35e8343bf5007bd8b6f3a3f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2776cca35e8343bf5007bd8b6f3a3f8f">&#9670;&nbsp;</a></span>Index_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a> =  IIndex_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5508d82b795e6c1977bebb67b5e5b686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508d82b795e6c1977bebb67b5e5b686">&#9670;&nbsp;</a></span>Link_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> =  ILink_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac44b7846713e20e26a7eede2492fda47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44b7846713e20e26a7eede2492fda47">&#9670;&nbsp;</a></span>Node_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#ac44b7846713e20e26a7eede2492fda47">Node_t</a> =  <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3931e84d06ddd3b436103475197eb12a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3931e84d06ddd3b436103475197eb12a">&#9670;&nbsp;</a></span>Pointer_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a3931e84d06ddd3b436103475197eb12a">Pointer_t</a> =  unsigned long long int</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7636b4884545094b9532cc295604b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7636b4884545094b9532cc295604b17">&#9670;&nbsp;</a></span>This_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#aa7636b4884545094b9532cc295604b17">This_t</a> =  <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">Allocator</a>&lt;T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc2d0f788ae4d12cdfb3b2d3e8075c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2d0f788ae4d12cdfb3b2d3e8075c77">&#9670;&nbsp;</a></span>Allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">Allocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sync all initial values to global memory before doing anything. Client code should wait on thread that calls this constructor so that it gets a consistent view of the allocator instance after initialization. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1d1b9fa15fea39ba361ca1cdc5bfaeb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1b9fa15fea39ba361ca1cdc5bfaeb9">&#9670;&nbsp;</a></span>atomicRead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<div class="memtemplate">
template&lt;typename TypeToRead &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ TypeToRead <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::atomicRead </td>
          <td>(</td>
          <td class="paramtype">TypeToRead *&#160;</td>
          <td class="paramname"><em>pLink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Hack to simulate an atomic read (TODO replace this once CUDA supports something similar) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLink</td><td>pointer to TypeToRead that is read atomically (avoids torn views of data) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a local copy of the memory pointed to by the input link </dd></dl>

</div>
</div>
<a id="abb86daaaec98eadd094bc3f6520bb1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb86daaaec98eadd094bc3f6520bb1d8">&#9670;&nbsp;</a></span>atomicWrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<div class="memtemplate">
template&lt;typename TypeToWrite &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ void <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::atomicWrite </td>
          <td>(</td>
          <td class="paramtype">TypeToWrite *&#160;</td>
          <td class="paramname"><em>pLink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeToWrite &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Hack to simulate an atomic write (TODO replace this once CUDA supports something similar) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pLink</td><td>the destination in which to store the value </td></tr>
    <tr><td class="paramname">val</td><td>the value to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0498950ecff0d5354daab89e8f12d6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0498950ecff0d5354daab89e8f12d6d5">&#9670;&nbsp;</a></span>CleanUpAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::CleanUpAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdfba24913e993f6572d4a5b0f6c701c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfba24913e993f6572d4a5b0f6c701c">&#9670;&nbsp;</a></span>CleanUpLocal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::CleanUpLocal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a>&#160;</td>
          <td class="paramname"><em>callingThread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44f1e3d3b32739a116a7acccae7b29db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f1e3d3b32739a116a7acccae7b29db">&#9670;&nbsp;</a></span>CompareAndSwapLinks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __device__ bool <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::CompareAndSwapLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> *&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> &amp;&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an atomic compare and swap on Link_t by treating Link_t as a Pointer_t integral type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>a pointer to the link to be conditionally modified </td></tr>
    <tr><td class="paramname">old</td><td>if the link to be conditionally modified is equal to this value, its value will be updated </td></tr>
    <tr><td class="paramname">node</td><td>the new value to assign to the first argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eeb962b3169fa2bdffe85e7d682dfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eeb962b3169fa2bdffe85e7d682dfa9">&#9670;&nbsp;</a></span>CompareAndSwapRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ bool <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::CompareAndSwapRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> *&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a>&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs an atomic compare and swap with the input arguments as they are in CompareAndSwapLinks. If the atomic compare and swap succeeds, the ref count of old is decremented and the ref count of node is incremented. </p><dl class="section return"><dt>Returns</dt><dd>whether or not the the atomic compare and swap succeeded </dd></dl>

</div>
</div>
<a id="a3f2abafd921e216ec08249198da2d3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2abafd921e216ec08249198da2d3d2">&#9670;&nbsp;</a></span>DeleteNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::DeleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a>&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free the hazard pointer allocated to the node pointed to by the input link. Add the node pointed to to this thread's deletion list. If the thread's deletion list is too long, start attempting to reclaim the memory of deleted nodes (see Scan) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link to the node to be deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c5eef54aaebcad88edb0e87d5b7557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c5eef54aaebcad88edb0e87d5b7557">&#9670;&nbsp;</a></span>DeRefLink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::DeRefLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fetch the value pointed to by a link. Reserve a hazard pointer and store the node at the end of the link in the hazard pointer table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link to dereference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the dereferenced link </dd></dl>

</div>
</div>
<a id="a3bf029c737539d9bfa9c9296ac17d83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf029c737539d9bfa9c9296ac17d83b">&#9670;&nbsp;</a></span>findIndexWhereEqual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<div class="memtemplate">
template&lt;Index_t height, Index_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a> <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::findIndexWhereEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>input</em>[height][width], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a>&#160;</td>
          <td class="paramname"><em>callingThread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4749c1ddff91fcdff56e750545a6790a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4749c1ddff91fcdff56e750545a6790a">&#9670;&nbsp;</a></span>NewNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::NewNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a new node from the GPU heap. Allocate a hazard pointer for it. </p><dl class="section return"><dt>Returns</dt><dd>a link to the newly created node </dd></dl>

</div>
</div>
<a id="a7c4e8ba73a5018483ca63c09f94daca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4e8ba73a5018483ca63c09f94daca3">&#9670;&nbsp;</a></span>ReleaseRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::ReleaseRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a>&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free the hazard pointer allocated to the node pointed to by a link. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link to release a reference to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5813e074d787aa0fc50f1b02061a973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5813e074d787aa0fc50f1b02061a973">&#9670;&nbsp;</a></span>Scan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::Scan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a2776cca35e8343bf5007bd8b6f3a3f8f">Index_t</a>&#160;</td>
          <td class="paramname"><em>callingThread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a08cd8b51995e5cebbc937a3a01aa1eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cd8b51995e5cebbc937a3a01aa1eff">&#9670;&nbsp;</a></span>StoreRef()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::StoreRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a> *&#160;</td>
          <td class="paramname"><em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a5508d82b795e6c1977bebb67b5e5b686">Link_t</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the value of a link such that the ref counts of the linked nodes are consistent with the change. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>the link to have its value swapped. The previously linked node will have its ref count decremented. </td></tr>
    <tr><td class="paramname">node</td><td>the value that will replace the previously linked value of the first arg. The linked node's ref count will be incremented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bd90fb5b60a5e8099775c1725a0613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd90fb5b60a5e8099775c1725a0613d">&#9670;&nbsp;</a></span>updateRefCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">__device__ void <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::updateRefCounts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae185b38ec0a4ca4ccbe4ec0060ca834b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae185b38ec0a4ca4ccbe4ec0060ca834b">&#9670;&nbsp;</a></span>CleanUpNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CleanUpNode_t <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::CleanUpNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa50f17cb2e163dbd88a3fcb492b1dde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50f17cb2e163dbd88a3fcb492b1dde2">&#9670;&nbsp;</a></span>DLClaims</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile int <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::DLClaims[numThreads][<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a1d220e1cc963fc9fb37e46a416504715">threshold1</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af93543d254eaef573bd4fb471c79ae29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93543d254eaef573bd4fb471c79ae29">&#9670;&nbsp;</a></span>DLDone</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::DLDone[numThreads][<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a1d220e1cc963fc9fb37e46a416504715">threshold1</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a040473eedb2591853976bd963e8522e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040473eedb2591853976bd963e8522e6">&#9670;&nbsp;</a></span>DLNodes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a>* <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::DLNodes[numThreads][<a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html#a1d220e1cc963fc9fb37e46a416504715">threshold1</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcefaf024a5ea626d6e045aab70057b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcefaf024a5ea626d6e045aab70057b9">&#9670;&nbsp;</a></span>GetThisThreadID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GetThisThreadID_t <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::GetThisThreadID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af296445f1e849188577b21cdc924b09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af296445f1e849188577b21cdc924b09e">&#9670;&nbsp;</a></span>HP</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_node.html">Node</a>* <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::HP[numThreads][indicesPerThread]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa04805cb0313b2b7cfd5c76830fdb0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04805cb0313b2b7cfd5c76830fdb0c8">&#9670;&nbsp;</a></span>perThreadState</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator_1_1_per_thread_state.html">PerThreadState</a> <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::perThreadState[numThreads]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14e7ae467e3fefce5ce92aa3017b1568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e7ae467e3fefce5ce92aa3017b1568">&#9670;&nbsp;</a></span>TerminateNode</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TerminateNode_t <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::TerminateNode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d220e1cc963fc9fb37e46a416504715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d220e1cc963fc9fb37e46a416504715">&#9670;&nbsp;</a></span>threshold1</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename ILink_t, typename IIndex_t, typename TerminateNode_t, typename CleanUpNode_t, typename GetThisThreadID_t, IIndex_t indexSentinel, IIndex_t numThreads, IIndex_t indicesPerThread, IIndex_t maxLinks, IIndex_t maxLinksToDeletedNode, IIndex_t scanThreshold, unsigned long long int nodeAlignment = 8&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="class_n_u_c_a_r_lock_free_d_s_1_1_allocator.html">NUCARLockFreeDS::Allocator</a>&lt; T, ILink_t, IIndex_t, TerminateNode_t, CleanUpNode_t, GetThisThreadID_t, indexSentinel, numThreads, indicesPerThread, maxLinks, maxLinksToDeletedNode, scanThreshold, nodeAlignment &gt;::threshold1 = numThreads * (indicesPerThread + maxLinks + maxLinksToDeletedNode + 1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>GPULockFreeDataStructures/<a class="el" href="_allocator_8hpp_source.html">Allocator.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
